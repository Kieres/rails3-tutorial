#### {% title "Autentykacja" %}

# Authentication

<blockquote>
 {%= image_tag "/images/binary-logic.gif", :alt => "[Binary Logic]" %}
 <p>An authentication system is how you identify yourself to 
  the computer. The goal behind an authentication system is 
  to verify that the user is actually who they say they are.</p>
 <p>There are many ways of authenticating a user. A good
  example is <i>logging</i> which is
  a password based authentication.</p>
</blockquote>

There seems to be a consensus to choose Ben Johnsos 
[Authlogic] [authlogic] as the Rails way of securely 
identifying the users, at least with local user databases.

W przykładach poniżej będę korzystał ze generatorów z gemu
[nifty-generators] [nifty generators].
*Proste ćwiczenie z nifty layout*: zmienić domyślne tytuły stron.


## Jak to działa?

Przykład do obejrzenia jest tutaj:
[Railscasts: \#160 Authlogic] [railscasts authlogic]
a do poczytania tutaj: [ASCIIcasts: \#160 Authlogic] [asciicasts authlogic] 

Przykład wart jest tysiąca słów. 
Dodamy autentykację do *Fortunki*. Tylko zalogowany użytkownik
będzie mógł usuwać i edytować cytaty. Pozostali użytkownicy
będą mogli przeglądać i dodawać cytaty.

Zaczynamy od utworzenia prostej wersji *Fortunki*:

    :::ruby
    rails fortunka
    cd fortunka
    script/generate nifty_layout
    script/generate nifty_scaffold fortune quotation:text
    rake db:migrate
    rm public/index.html

Na koniec w pliku *routes.rb* dopisujemy:

    :::ruby
    map.root :controller => "fortunes", :action => "index"

usuwamy domyślny routing:

    :::ruby
    map.connect ':controller/:action/:id'
    map.connect ':controller/:action/:id.:format'

dopisujemy gem *Authlogic* w pliku *environment.rb*:

    :::ruby
    config.gem "authlogic"  

i sprawdzamy, czy gem jest już zainstalowany:

    sudo rake gems:install

Gotowe! Uruchamiamy aplikację:

    script/server thin

i wchodzimy na stronę:

    http://localhost:3000/

Jak każe zwyczaj, na tej stronie, w prawym górnym rogu, umieścimy
linki do rejestracji i logowania.

Do pamiętania danych zarejestrowanych użytkowników utworzymy
model *User*, a do rejestracji utworzymy kontroler *UsersController*:

    script/generate nifty_scaffold user \
      login:string email:string password:string new edit

Ponieważ nie chcemy zapamiętywać haseł w czystym tekście, więc
edytujemy utworzoną migrację zmieniając:

    :::ruby
    t.string :login
    t.string :password

na

    :::ruby
    t.string :login, :null => false
    t.string :email, :null => false
      
    t.string :crypted_password, :null => false
    t.string :password_salt, :null => false
    t.string :persistence_token, :null => false

Dlaczego *crypted_password*: ponieważ Authlogic oczekuje takiej nazwy.
Do czego służą pola: *password_salt* i *persistence_token*?
Więcej o polach w dokumentacji do aplikacji 
*Authlogic Example*: [Ensure proper database fields] [authlogic example].

Na potrzeby „Resetting password…” dodajemy kilka pól:

    :::ruby     
    t.string :login, :null => false
    t.integer :login_count, :default => 0, :null => false
    t.datetime :last_request_at
    t.datetime :last_login_at
    t.datetime :current_login_at
    t.string :last_login_ip
    t.string :current_login_ip

Po wprowadzeniu poprawek, migrujemy:

    rake db:migrate

Aby aktywować autentykację, edytujemy kod modelu *User*:

    :::ruby
    class User < ActiveRecord::Base
      acts_as_authentic  
    end

### Rejestracja


W pliku *layout/application.html.erb* dodajemy element *div*:

    :::html
    <div id="user_nav">
      <%= link_to "Register", new_user_path %>
    </div>

który umieszczamy w prawym górnym rogu strony:

    :::css
    #user_nav {
      float: right;
    }

Przeładowujemy aplikację i klikamy w link *Register*:

{%= image_tag "/doc/authentication/register-1.png", :alt => "[generated register view]" %}

Wygenerowany widok musimy zmienić, na taki:

{%= image_tag "/doc/authentication/register-2.png", :alt => "[generated register view]" %}

Zmieniamy w widoku *users/_form.html.erb*:

    :::html
    <p>
    <%= f.label :password %><br />
    <%= f.text_field :password %>
    </p>

na

    :::html
    <p>
    <%= f.label :password %><br />
    <%= f.password_field :password %>
    </p>
    <p>
    <%= f.label :password_confirmation %><br />
    <%= f.password_field :password_confirmation %>
    </p>

oraz edytujemy plik *users_controller.rb*:

    :::ruby
    class UsersController < ApplicationController
      ...      
      def create
        @user = User.new(params[:user])
        if @user.save
          flash[:notice] = "Registration successfull."
          redirect_to root_url
        else
          render :action => 'new'
        end
      end

Sprawdzamy rezultaty wchodząc na stronę:

    http://localhost:3000/users/new 

### Logowanie

Implementację logowania zaczynamy od wygenerowania
modelu *UserSession* (**konwencja nazewnicza *Authlogic***).
Korzystamy z generatora *Authlogic*:

    script/generate session user_session

Wygenerowany plik *models/user_session.rb* zawiera kod:

    :::ruby
    class UserSession < Authlogic::Session::Base
    end

Zauważmy, że tym razem nie została wygenerowana migracja.
Dlaczego?

Do sterowania potrzebujemy kontrolera:

    script/generate nifty_scaffold user_session --skip-model\
      login:string email:string password:string new destroy

W wygenerowanym pliku *user_sessions_controller.rb* zmieniamy
komunikaty:

    :::ruby
    flash[:notice] = "Successfully created user session."
    flash[:notice] = "Successfully destroyed user session."

na:

    :::ruby
    flash[:notice] = "Successfully logged in."
    flash[:notice] = "Successfully logged out."

oraz 

    :::ruby
    @user_session = UserSession.find(params[:id])

na:

    :::ruby
    @user_session = UserSession.find

Dlaczego? Odpowiedź: sesja jest tylko jedna.

W widoku *user_sessions/new.html.erb* zmieniamy tytuł:
"New User Session" na "Logging" oraz 

    :::html
    <%= f.text_field :password %>

na:

    :::html
    <%= f.password_field :password %>

Zmieniamy routing dla logowania i wylogowywania na zwyczajowe
login i logout:

    :::ruby
    map.login "login", :controller => "user_sessions", :action => "new"
    map.logout "logout", :controller => "user_sessions", :action => "destroy"

Pozostało jeszcze uaktualnić element *div* w pliku *layout/application.html.erb*:

    :::html
    <div id="user_nav">
      <%= link_to "Register", new_user_path %> |
      <%= link_to "Login", login_path %>
    </div>

i możemy sprawdzić jak to działa:

    http://localhost:3000/

To jeszcze nie jest to o co chodzi. Zmieniamy *div*:

    :::html
    <div id="user_nav">
      <% if logged_in? %>
        <%= link_to "Edit Profile", edit_user_path(:current) %> |
        <%= link_to "Logout", logout_path %>
      <% else %>
        <%= link_to "Register", new_user_path %> |
        <%= link_to "Login", login_path %>
      <% end %>
    </div>

gdzie metodę *logged_in?* musimy sami napisać.

Pytanie: co oznacza symbol *:current* powyżej?
Czy symbol ten jest definiowany w *Authlogic*, czy w *ActiveRecord*?

Odpowiedź: nie i nie. Symbol *:current* można zastąpić
jakimkolwiek innym symbolem, np. *:whatever*.

*Uwaga*: Jeśli zamienimy

    :::ruby
    edit_user_path(:current)

na

    :::ruby
    edit_user_path(current_user.username)

to wygenerowany URI będzie podobny do:

    http://localhost:3000/users/wbzyl/edit

\(Sprawdzić!\)


Definicję metody *current_user* znajdziemy w dokumentacji do przykładu
[authlogic_example] [authlogic example]. 
Poniższe definicje wklejamy do pliku *application_controller.rb*:

    :::ruby
    helper_method :current_user, :logged_in?,
      :require_user, :require_no_user, :redirect_back_or_default
      
    private
      
    def current_user_session
      return @current_user_session if defined?(@current_user_session)
      @current_user_session = UserSession.find
    end
    
    def current_user
      return @current_user if defined?(@current_user)
      @current_user = current_user_session && current_user_session.record
    end
      
    def logged_in?
      current_user != nil
    end

Na potrzeby rozdziału „Resetting password…” dopisujemy kilka metod:

    :::ruby
    def require_no_user
     if current_user
        store_location
        flash[:notice] = "You must be logged out to access this page"
        redirect_to root_url # inny uri?
        return false
      end
    end
    
    # niepotrzebne
    def redirect_back_or_default(default)
      redirect_to(session[:return_to] || default)
      session[:return_to] = nil
    end

Po tych poprawkach, wchodzimy na stronę główną aplikacji:

    http://localhost:3000/

i klikamy link *Edit profile*. Link ten generuje błąd.
Aby go poprawić, zmieniamy w wygenerowany kod metod 
dla *edit* oraz *update* kontrolera *users_controller.rb*:

    :::ruby
    def edit
      @user = User.find(params[:id])
    end

na:

    :::ruby
    def edit
      @user = current_user
    end

Analogiczną poprawkę robimy w kodzie metody *update*.
Przy okazji zmieniamy komunikat z "Successfully updated user."
na: "Successfully updated profile.".

Po tych poprawkach, możemy uaktualnić profil zalogowanego użytkownika.

### Restrict access

Jak zapewnić sobie aby **tylko** zalogowany użytkownik mógł edytować
i usuwać istniejące cytaty.

Dopisujemy do *application_controller.rb*:

    :::ruby
    helper_method :require_user
      
    private

    def require_user
      unless current_user
        store_location
        flash[:notice] = "You must be logged in to access this page"
        redirect_to new_user_session_url
        return false
      end
    end
    
    def store_location
      session[:return_to] = request.request_uri
    end

oraz do *fortunes_controller.rb*: 

    :::ruby
    class FortunesController < ApplicationController
      before_filter :require_user, :only => [:edit, :update, :destroy]

Zmieniamy kod widoków: *fortunes/index.html.erb*, *fortunes/show.html.erb*
dopisując gdzie trzeba:

    :::html
    <% if logged_in? %>
    ...
    <% end %>


### Bezpieczeństwo

Dopisujemy do *application_controller.rb*:

    :::ruby
    filter_parameter_logging :password, :password_confirmation

Jakie pola powinniśmy jeszcze odfiltrować?

### Pozostałe szczegóły 

Teraz należy przeczytać ze zrozumieniem dokumentację:
[Authlogic Example](http://github.com/binarylogic/authlogic_example/).

### Lekcja do odrobienia: lokalizacja

Lokalizacja, czyli *i18n*. Przetłumaczyć na język polski komunikaty *Authlogic*.
Przygotować zlokalizowaną wersję *Fortunki*.

Jak się to robi? Zobacz [Railscasts \#138: i18n] [railscasts i18n].
 

## Coś prostszego: nifty layouts

Najnowsza wersja gemu [nifty-generators] [nifty generators] zawiera generator
*nifty_authentication*. 

Przeczytać dokumentację:

    script/generate nifty_authentication --help

Jakieś pytania?


## Jak zmienić zapomniane hasło?

[Tutorial: Reset passwords with Authlogic the RESTful way] [reset passwords with authlogic]

Zaczynamy od konfiguracji *Action Mailer* dla trybu *development*.
W pliku *config/environments/development.rb* dopisujemy:

    :::ruby
    config.action_mailer.smtp_settings = {
      :address => 'manta.univ.gda.pl',
      :user_name => 'wbzyl',
      :password => 'sekret'
    }
    
    config.action_mailer.delivery_method = :sendmail
    config.action_mailer.sendmail_settings = {
      :location => '/usr/sbin/sendmail',
      :arguments => '-i -t'
    }
    
    config.action_mailer.perform_deliveries = true
    config.action_mailer.raise_delivery_errors = true
    config.action_mailer.default_charset = 'utf-8'

Albo lepiej, tworzymy plik 'initializers/manta.rb' o następującej zawartości:

    :::ruby
    ActionMailer::Base.smtp_settings = {
      :address => 'manta.univ.gda.pl',
      :user_name => 'wbzyl',
      :password => 'sekret'
    }
    
    ActionMailer::Base.delivery_method = :sendmail
    config.action_mailer.sendmail_settings = {
      :location => '/usr/sbin/sendmail',
      :arguments => '-i -t'
    }
    
    ActionMailer::Base.perform_deliveries = true
    ActionMailer::Base.raise_delivery_errors = true
    ActionMailer::Base.default_charset = 'utf-8'



### Reset password… krok po kroku

1. A user requests a password reset
2. An email is sent to them with a link to reset their password
3. The user verifies their identity be using the link we emailed them
4. They are presented with a basic form to change their password
5. After they change their password we log them in, redirect them to
   their account, and expire the URL we just sent them

Przesłany mail będzie zawierał link zawierający tekst podobny do:
`4LiXF7FiGUppIPubBPey`. Ten tekst nazywamy **perishable_token**.
Jest on pamiętany w polu *perishable_token* tabeli *users*.

*Authlogic* zarządza tym tokenem w następujący sposób:

* The token gets set to a unique value before validation, 
  which constantly changes the token.
* After a session is successfully saved (aka logged in) 
  the the token will be reset. 

Tworzymy migrację, która doda token to tabeli:

    script/generate migration add_users_password_reset_fields

i modyfikujemy ją w następujący sposób:

    :::ruby
    class AddUsersPasswordResetFields < ActiveRecord::Migration  
      def self.up  
        add_column :users, :perishable_token, :string, 
            :default => "", :null => false  
        
        add_index :users, :perishable_token  
        add_index :users, :email  
      end  
      
      def self.down  
        remove_column :users, :perishable_token  
      end  
    end  

### Zmiana hasła na sposób REST

Tworzymy resource o nazwie *password resets*. 

Zaczynamy od dopisania do routingu:

    :::ruby
    map.resources :password_resets

generujemy pusty kontroler:

    script/generate controller password_resets

i wpisujemy poniższy kod (na razie tylko tyle):

    :::ruby
    class PasswordResetsController < ApplicationController
      before_filter :load_user_using_perishable_token, :only => [:edit, :update]
      
      # make sure the user is logged out when accessing these methods
      before_filter :require_no_user
      
      def new
        render
      end
      
      private
        def load_user_using_perishable_token
          @user = User.find_using_perishable_token(params[:id])
          unless @user
            flash[:notice] = "We're sorry, but we could not locate your account." +
              "If you are having issues try copying and pasting the URL " +
              "from your email into your browser or restarting the " +
              "reset password process."
            redirect_to root_url
          end
        end
    end

Method *find_using_perishable_token* is a special in *Authlogic*. 
Here is what it does for extra security:

* Ignores blank tokens
* Only finds records that match the token and have an updated_at (if
  present) value that is not older than 10 minutes. This way, if
  someone gets the data in your database any valid perishable tokens
  will expire in 10 minutes. Chances are they will expire quicker
  because the token is changing during user activity as well.

Widok *new.html.erb* dla tego kontrolera:

    :::html
    <h1>Forgot Password</h1>
    
    <p>Fill out the form below and instructions 
       to reset your password will be emailed to you:
    </p>
    
    <% form_tag password_resets_path do %>
      <label>Email:</label><br />
      <%= text_field_tag "email" %><br />
      <br />
      <%= submit_tag "Reset my password" %>
    <% end %>

Kilknięcie na przycisk "Reset my password" powoduje wywołanie 
metody *create* tego kontrolera:

    :::ruby
    def create
      @user = User.find_by_email(params[:email])
      if @user
        @user.deliver_password_reset_instructions!
        flash[:notice] = "Instructions to reset your password have been emailed to you. " +
          "Please check your email."
        redirect_to root_url
      else
        flash[:notice] = "No user was found with that email address"
        render :action => :new
      end
    end

### Email z linkiem do zmiany hasła 

Zobacz [Action Mailer Basics: 2.2 Action Mailer and Dynamic deliver_<method_name> 
methods] [rails guides mailer].

Wysyłanie emaila z linkiem realizuje metoda *deliver_password_reset_instructions!*.
Za wysłanie odpowiedzialna jest klasa *Notifier*.

    :::ruby
    class User < ActiveRecord::Base
      acts_as_authentic
      
      def deliver_password_reset_instructions!
        reset_perishable_token!
        Notifier.deliver_password_reset_instructions(self)
      end

gdzie metoda *reset\_perishable\_token!* gemu *Authlogic*
nadaje nową przypadkową wartość polu *perishable_token*.

Pozostaje zdefiniować **model** *Notifier* i w niej metodę 
*password_reset_instructions* (nazwa bez prefixu *deliver*):

    :::ruby
    class Notifier < ActionMailer::Base
      # production
      # default_url_options[:host] = "manta.univ.gda.pl:3000"
      # development
      default_url_options[:host] = "localhost:3000"
      
      def password_reset_instructions(user)
        subject    "Password Reset Instructions"
        from       "Fortune Notifier <noreply@localhost>"
        recipients  user.email
        sent_on     Time.now
        body        :edit_password_reset_url => 
                       edit_password_reset_url(user.perishable_token)
      end
    end

Szablon emaila, to widok *notifier/password_reset_instructions.erb*:

    :::html
    A request to reset your password has been made. 
    If you did not make this request, simply ignore this email. 
    If you did make this request just click the link below:
    
    <%= @edit_password_reset_url %>
    
    If the above URL does not work try copying and pasting 
    it into your browser. If you continue to have problem 
    please feel free to contact us.

### Użytkownik kilka na link w emailu

Link który użytkownik ma kliknąć w emailu będzie wyglądał tak:

    http://manta.univ.gda.pl:3000/password_resets/6th8mSFwxvG-v2IbbRdY/edit    

Po kliknięciu wykonana zostanie metoda *edit* klasy *PasswordResetsConttoller*:

    :::ruby
    def edit
      render
    end

która renderuje widok *edit.html.erb*:    
    
    :::ruby
    <h1>Change My Password</h1>
    
    <% form_for @user, :url => password_reset_path, :method => :put do |f| %>
      <%= f.error_messages %>
      <%= f.label :password %><br />
      <%= f.password_field :password %><br />
      <br />
      <%= f.label :password_confirmation %><br />
      <%= f.password_field :password_confirmation %><br />
      <br />
      <%= f.submit "Update my password and log me in" %>
    <% end %>

Wyrenderowany formularz wygląda mniej więcej tak
(gdzie "RgfuGYh4yU6qbQIsIeiE" poniżej, to *perishable_token*):

    :::html
    <form action="/password_resets/RgfuGYh4yU6qbQIsIeiE" id="edit_user_1" method="put">
    ...
    <input id="user_password" name="user[password]" size="30" type="password" />
    ...

Oznacza to, że po kliknięciu na przycisk submit zostanie wywołana
metoda *update* klasy *PasswordResetsConttoller*:

    :::ruby
    def update
      @user.password = params[:user][:password]
      @user.password_confirmation = params[:user][:password_confirmation]
      if @user.save
        flash[:notice] = "Password successfully updated"
        redirect_to root_url # albo jakieś inne uri?
      else
        render :action => :edit
      end
    end

### Hooking into Fortunes

W widoku *layout/application.html.erb* w elemencie *div#user_nav*
dopisujemy link do "Forgot password":

    :::html
    <div id="user_nav">
      <% if current_user %>
        <%= link_to "Edit Profile", edit_user_path(:current) %> |
        <%= link_to "Logout", logout_path %> |
        Hello <em><%= current_user.login %></em>
      <% else %>
        <%= link_to "Register", new_user_path %> |
        <%= link_to "Login", login_path %> |
        <%= link_to "Forgot password", new_password_reset_path %>
      <% end %>
    </div>


#### Linki

[authlogic]: http://github.com/binarylogic/authlogic/  "binarylogic's authlogic at master"
[railscasts authlogic]: http://railscasts.com/episodes/160-authlogic/  "Railscasts — Authlogic"
[asciicasts authlogic]: http://asciicasts.com/episodes/160-authlogic/  "ASCIIcasts — Authlogic"
[reset passwords with authlogic]: http://www.binarylogic.com/2008/11/16/tutorial-reset-passwords-with-authlogic/ 
  "Reset passwords…"
[nifty generators]: http://github.com/ryanb/nifty-generators/ "A collection of useful Rails generator scripts"
[authlogic example]: http://github.com/binarylogic/authlogic_example/ "binarylogic's authlogic_example at master"
[railscasts i18n]: http://railscasts.com/episodes/138-i18n/ "Railscasts — i18n"
[rails guides mailer]: http://guides.rubyonrails.org/action_mailer_basics.html "Action Mailer Basics"
